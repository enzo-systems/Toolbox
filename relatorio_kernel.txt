[0;32m##################################################[0m
[0;32m###        RELAT√ìRIO DE ESTRUTURA E C√ìDIGO     ###[0m
[0;32m##################################################[0m

[1;33m>>> ESTRUTURA DE DIRET√ìRIOS:[0m
.
‚îú‚îÄ‚îÄ Agentes_Dados
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ career_hunter.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cotacao_dolar.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ global_news_sniper.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ news_sniper.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ Agentes_Monitor
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ README.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ sentinela.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ssl_hunter.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ system_expert.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ watchdog_sentinela.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ web_monitor.py
‚îú‚îÄ‚îÄ Agentes_Navegador
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ automatizar_formulario.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ automatizar_visual2.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ automatizar_visual.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ posicao_cursor_tela.py
‚îú‚îÄ‚îÄ Agentes_Visao
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ README.md
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ vision_processor.py
‚îú‚îÄ‚îÄ Agentes_Voz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ README.md
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ voice_synthesizer.py
‚îú‚îÄ‚îÄ Assets
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ Config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ README.md
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ settings.py
‚îú‚îÄ‚îÄ Data
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ csv
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cotacao_dolar.csv
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ produtos_automacao_formulario.csv
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ input_audio
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ referencia.m4a
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ roteiro.txt
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ input_images
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ perfil.jpg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ auditoria_ssl.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ global_news_memory.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ memoria_world.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ news_sniper_memory.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ sentinela_status.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ vagas_encontradas.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ web_monitor_results.json
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ output_audio
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ output_images
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ perfil_perfil.png
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ui_assets
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ campo_codigo_automatizar_visual.png
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ campo_email_automatizar_visual.png
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ Docker
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ Docs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ Logs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ Scripts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ audit_project.sh
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ backup_toolbox.sh
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ relatorio_kernel.txt

20 directories, 47 files

[0;32m##################################################[0m
[0;32m###             CONTE√öDO DOS ARQUIVOS          ###[0m
[0;32m##################################################[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Dados/career_hunter.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 2: Career Hunter
STATUS: Corrigido com Debug de Caminhos Absolutos.
"""

import sys
import requests
import json
from bs4 import BeautifulSoup
from pathlib import Path
from datetime import datetime

# --- BOOTSTRAP ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    ARQUIVO_SAIDA = DIRS["JSON"] / "vagas_encontradas.json"
except ImportError:
    ARQUIVO_SAIDA = BASE_DIR / "Data" / "json" / "vagas_encontradas.json"

ARQUIVO_SAIDA.parent.mkdir(parents=True, exist_ok=True)

def buscar_vagas():
    url = "https://www.python.org/jobs/"
    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'}
    
    print(f"üìÅ [DEBUG] Banco de Vagas: {ARQUIVO_SAIDA}")
    print(f"üëî [Career Hunter] Monitorando: {url}")
    
    try:
        resposta = requests.get(url, headers=headers, timeout=15)
        soup = BeautifulSoup(resposta.text, 'html.parser')
        vagas_html = soup.find_all('h2', class_='listing-company')
        
        achados = []
        termos = ["brazil", "remote", "latam", "south america"]
        
        print(f"üîé Analisando {len(vagas_html)} ofertas...")
        
        for item in vagas_html:
            texto = item.get_text(strip=True)
            if any(t in texto.lower() for t in termos):
                link = "https://www.python.org" + item.find('a')['href'] if item.find('a') else "N/A"
                print(f"   üéØ OPORTUNIDADE: {texto}")
                achados.append({
                    "data": datetime.now().strftime("%Y-%m-%d"),
                    "vaga": texto,
                    "link": link
                })
        return achados

    except Exception as e:
        print(f"‚ùå Erro: {e}")
        return []

def salvar_resultados(novas):
    if not novas:
        print("üí§ Nada encontrado hoje.")
        return

    dados_db = []
    if ARQUIVO_SAIDA.exists():
        with open(ARQUIVO_SAIDA, 'r', encoding='utf-8') as f:
            try: dados_db = json.load(f)
            except: dados_db = []

    links_db = {item['link'] for item in dados_db}
    
    reais = [v for v in novas if v['link'] not in links_db]
    
    if not reais:
        print(f"üîÑ Todas as {len(novas)} vagas encontradas j√° existem em:\n   üìÑ {ARQUIVO_SAIDA}")
        return

    dados_db.extend(reais)
    with open(ARQUIVO_SAIDA, 'w', encoding='utf-8') as f:
        json.dump(dados_db[-200:], f, indent=4, ensure_ascii=False)
        
    print(f"‚úÖ {len(reais)} novas vagas salvas em:\n   üìÑ {ARQUIVO_SAIDA}")

if __name__ == "__main__":
    vagas = buscar_vagas()
    salvar_resultados(vagas)
[1;33m‚¨áÔ∏è  FIM DE career_hunter.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Dados/cotacao_dolar.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 2: Agente Financeiro Aut√¥nomo
FUN√á√ÉO: Captura cota√ß√µes em tempo real via API e gera s√©ries hist√≥ricas.
CONCEITOS: Integra√ß√£o de APIs REST, Configura√ß√£o Centralizada, Persist√™ncia CSV.
"""

import sys
import requests
import csv
from datetime import datetime
from pathlib import Path

# --- BOOTSTRAP: CONEX√ÉO COM O SETTINGS ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import CAMBIO_CONFIG, DIRS
except ImportError:
    print("‚ùå Erro: N√£o foi poss√≠vel localizar Config/settings.py")
    sys.exit(1)

def buscar_cotacao():
    try:
        response = requests.get(CAMBIO_CONFIG["url_api"], timeout=10)
        response.raise_for_status()
        data = response.json()
        par = list(data.keys())[0]
        return data[par]['bid']
    except Exception as e:
        print(f"‚ö†Ô∏è Falha na coleta: {e}")
        return None

def salvar_dados(valor):
    if not valor: return
    
    # Garantimos que o arquivo seja salvo dentro de Data/
    arquivo = DIRS["DATA"] / "cotacao_dolar.csv"
    header = ['Data_Hora', 'Valor_BRL']
    existe = arquivo.exists()
    agora = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    with open(arquivo, 'a', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        if not existe:
            writer.writerow(header)
        writer.writerow([agora, valor])
    
    print(f"‚úÖ Registro arquivado em: Data/{arquivo.name} | Valor: R$ {valor}")

if __name__ == "__main__":
    cotacao = buscar_cotacao()
    salvar_dados(cotacao)
[1;33m‚¨áÔ∏è  FIM DE cotacao_dolar.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Dados/global_news_sniper.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 2: Agente de Intelig√™ncia de Dados (Global Sniper)
FUN√á√ÉO: Coleta e processa not√≠cias internacionais via RSS (Feedparser).
CONCEITOS: RSS Parsing, Normaliza√ß√£o de Dados, Persist√™ncia JSON.
"""

import sys
import json
import time
import feedparser  # pip install feedparser
from pathlib import Path
from urllib.parse import quote 

# --- BOOTSTRAP: CONEX√ÉO COM O SETTINGS ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    # CORRE√á√ÉO S√äNIOR: Salvamos na pasta espec√≠fica de JSON
    ARQUIVO_MEMORIA = DIRS["JSON"] / "global_news_memory.json"
except ImportError:
    # Fallback seguro
    ARQUIVO_MEMORIA = BASE_DIR / "Data" / "json" / "global_news_memory.json"

# Garante que o diret√≥rio pai exista (caso rode isolado fora do main)
ARQUIVO_MEMORIA.parent.mkdir(parents=True, exist_ok=True)

# --- CONFIGURA√á√ÉO ---
TERMOS_ALVO = ["Intelig√™ncia Artificial", "Linux", "Python", "Ciberseguran√ßa"]

def carregar_memoria():
    if ARQUIVO_MEMORIA.exists():
        try:
            with open(ARQUIVO_MEMORIA, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"‚ö†Ô∏è Mem√≥ria corrompida ou vazia ({e}). Iniciando nova.")
            return []
    return []

def salvar_memoria(lista_vistos):
    try:
        with open(ARQUIVO_MEMORIA, 'w', encoding='utf-8') as f:
            # Mantendo os √∫ltimos 500 para controle de duplicatas
            json.dump(lista_vistos[-500:], f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå Erro ao salvar mem√≥ria: {e}")

def buscar_google_news():
    print(f"üåç [Global Sniper] Iniciando Varredura via Feedparser...")
    
    memoria = carregar_memoria()
    novas_descobertas = []

    for termo in TERMOS_ALVO:
        termo_safe = quote(termo)
        print(f"   üì° Sintonizando: [{termo}]...")
        
        # Google News RSS (Brasil)
        url = f"https://news.google.com/rss/search?q={termo_safe}&hl=pt-BR&gl=BR&ceid=BR:pt-419"
        
        try:
            feed = feedparser.parse(url)
            
            if feed.bozo: # feedparser flag para XML malformado
                 print(f"      ‚ö†Ô∏è Aviso: XML inst√°vel para {termo}")

            contador_termo = 0
            for entry in feed.entries:
                if contador_termo >= 3: 
                    break 
                
                titulo = entry.title
                link = entry.link
                
                if link not in memoria:
                    print(f"      üî• ALVO: {titulo[:60]}...")
                    memoria.append(link)
                    novas_descobertas.append({
                        "titulo": titulo, 
                        "link": link, 
                        "data": entry.get('published', 'N/A')
                    })
                    contador_termo += 1
        except Exception as e:
            print(f"      ‚ùå Erro ao ler feed: {e}")
        
        time.sleep(1) # Rate Limiting

    if novas_descobertas:
        salvar_memoria(memoria)
        print(f"‚úÖ Miss√£o cumprida. {len(novas_descobertas)} novos registros em {ARQUIVO_MEMORIA.name}.")
    else:
        print("üí§ Sem novidades no radar global.")

if __name__ == "__main__":
    buscar_google_news()
[1;33m‚¨áÔ∏è  FIM DE global_news_sniper.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Dados/news_sniper.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3 
"""
N√çVEL 2: Agente de Extra√ß√£o de Dados (News Sniper)
STATUS: Corrigido com Debug de Caminhos Absolutos.
"""

import sys
import requests
import json
from bs4 import BeautifulSoup
from pathlib import Path

# --- BOOTSTRAP ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    ARQUIVO_MEMORIA = DIRS["JSON"] / "news_sniper_memory.json"
except ImportError:
    ARQUIVO_MEMORIA = BASE_DIR / "Data" / "json" / "news_sniper_memory.json"

# Garante que a pasta existe
ARQUIVO_MEMORIA.parent.mkdir(parents=True, exist_ok=True)

URL_ALVO = "https://www.tabnews.com.br"
PALAVRAS_CHAVE = ["intelig√™ncia artificial", "linux", "python"]

def carregar_memoria():
    if ARQUIVO_MEMORIA.exists():
        try:
            with open(ARQUIVO_MEMORIA, 'r', encoding='utf-8') as f:
                return json.load(f)
        except: return []
    return []

def salvar_memoria(lista_vistos):
    try:
        with open(ARQUIVO_MEMORIA, 'w', encoding='utf-8') as f:
            json.dump(lista_vistos, f, indent=4)
        return True
    except Exception as e:
        print(f"‚ùå Erro de permiss√£o ao salvar em {ARQUIVO_MEMORIA}: {e}")
        return False

def ca√ßar_noticias():
    print(f"üìÅ [DEBUG] Arquivo de Mem√≥ria: {ARQUIVO_MEMORIA}")
    print(f"üïµÔ∏è  [News Sniper] Varrendo TabNews...")
    
    headers = {'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36'}

    try:
        response = requests.get(URL_ALVO, headers=headers, timeout=10)
        response.raise_for_status()
    except Exception as e:
        print(f"‚ùå Erro ao conectar: {e}")
        return

    soup = BeautifulSoup(response.text, 'html.parser')
    links = soup.find_all('a')
    
    memoria = carregar_memoria()
    novas_descobertas = []
    
    print(f"üîé Analisando {len(links)} links...")

    for link in links:
        titulo = link.get_text().strip()
        url_relativa = link.get('href')

        if not titulo or len(titulo) < 5 or not url_relativa: continue
            
        url_final = url_relativa if url_relativa.startswith('http') else f"{URL_ALVO}{url_relativa}"
        titulo_lower = titulo.lower()

        # Verifica Keywords
        encontrou = False
        match = ""
        for palavra in PALAVRAS_CHAVE:
            if palavra in titulo_lower:
                encontrou = True
                match = palavra
                break 
        
        if encontrou:
            if url_final not in memoria:
                print(f"   üéØ NOVO ALVO [{match.upper()}]: {titulo}")
                memoria.append(url_final)
                novas_descobertas.append(titulo)

    if novas_descobertas:
        salvar_memoria(memoria)
        print(f"‚úÖ Sucesso! {len(novas_descobertas)} novos itens salvos em:\n   üìÑ {ARQUIVO_MEMORIA}")
    else:
        # For√ßa a cria√ß√£o do arquivo mesmo se n√£o achar nada, pra voc√™ ver que funciona
        if not ARQUIVO_MEMORIA.exists():
            salvar_memoria(memoria)
            print(f"‚ö†Ô∏è Nenhuma not√≠cia nova, mas criei o arquivo de mem√≥ria inicial.")
        print(f"üí§ Sem novidades. (Verificado contra base em: {ARQUIVO_MEMORIA.name})")

if __name__ == "__main__":
    ca√ßar_noticias()
[1;33m‚¨áÔ∏è  FIM DE news_sniper.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Monitor/sentinela.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 2: Sentinela de Infraestrutura
FUN√á√ÉO: Vigia a conectividade e gerencia a rotatividade de logs do sistema.
CONCEITOS: I/O de Sistema, RotatingFileHandler, Daemonize Simulation.
"""

import sys
import time
import socket
import logging
import json
from logging.handlers import RotatingFileHandler
from pathlib import Path
from datetime import datetime

# --- BOOTSTRAP: CONEX√ÉO COM O SETTINGS ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    CAMINHO_LOG = DIRS["LOGS"] / "sentinela.log"
    STATUS_JSON = DIRS["JSON"] / "sentinela_status.json"
except ImportError:
    CAMINHO_LOG = Path("Logs/sentinela.log")
    STATUS_JSON = Path("Data/json/sentinela_status.json")

# --- 1. CONFIGURA√á√ÉO DE LOG ROTATIVO (PADR√ÉO S√äNIOR) ---
log_handler = RotatingFileHandler(
    CAMINHO_LOG, 
    maxBytes=2*1024*1024, # Reduzi para 2MB para ser mais √°gil
    backupCount=3,
    encoding='utf-8'
)

logging.basicConfig(
    handlers=[log_handler],
    level=logging.INFO, 
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

def checar_conexao():
    """Verifica conectividade via Socket TCP na porta 53 (DNS)."""
    try:
        socket.create_connection(("8.8.8.8", 53), timeout=3)
        return True
    except OSError:
        return False

def atualizar_status_visual(online):
    """Atualiza um JSON para que o main.py saiba o estado da rede sem ler logs."""
    status = {
        "ultimo_check": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "rede_online": online,
        "agente": "Sentinela"
    }
    with open(STATUS_JSON, 'w', encoding='utf-8') as f:
        json.dump(status, f, indent=4)

if __name__ == "__main__":
    print(f"üõ°Ô∏è  Sentinela iniciado. Log: {CAMINHO_LOG.name}")
    print("üö¶ Monitorando rede... (Pressione Ctrl+C para parar)")

    try:
        while True:
            online = checar_conexao()
            
            if online:
                logging.info("STATUS: ONLINE - Conectividade estabelecida.")
            else:
                logging.warning("ALERTA: OFFLINE - Falha de conex√£o detectada!")
            
            atualizar_status_visual(online)
            
            # O Arquiteto define o intervalo (60 segundos)
            time.sleep(60)
            
    except KeyboardInterrupt:
        print("\nüõë Sentinela desativado pelo usu√°rio.")
        logging.info("Sentinela encerrado manualmente.")
[1;33m‚¨áÔ∏è  FIM DE sentinela.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Monitor/ssl_hunter.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3 
"""
N√çVEL 2: Auditor de Criptografia e Redes
FUN√á√ÉO: Varredura e valida√ß√£o de certificados SSL/TLS em dom√≠nios externos.
CONCEITOS: pyOpenSSL, Protocolos de Seguran√ßa, Persist√™ncia de Auditoria.
"""

import sys
import ssl
import socket
import json
from datetime import datetime, timezone
from pathlib import Path

# --- BOOTSTRAP ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    ARQUIVO_RELATORIO = DIRS["DATA"] / "auditoria_ssl.json"
except ImportError:
    ARQUIVO_RELATORIO = Path(__file__).resolve().parent.parent / "Data" / "auditoria_ssl.json"

# Alvos de Auditoria
dominios = ["google.com", "python.org", "expired.badssl.com"]

def verificar_ssl(hostname):
    resultado = {"host": hostname, "status": "Erro", "dias_restantes": None, "timestamp": datetime.now().isoformat()}
    print(f"üîç Analisando seguran√ßa: {hostname}")
    
    context = ssl.create_default_context()
    try:
        with socket.create_connection((hostname, 443), timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                not_after = cert['notAfter']
                expiry_date = datetime.strptime(not_after, r'%b %d %H:%M:%S %Y %Z').replace(tzinfo=timezone.utc)
                days_left = (expiry_date - datetime.now(timezone.utc)).days
                
                resultado["dias_restantes"] = days_left
                if days_left < 0:
                    resultado["status"] = "VENCIDO"
                    print(f"‚ùå {hostname}: Certificado EXPIRADO!")
                else:
                    resultado["status"] = "OK"
                    print(f"‚úÖ {hostname}: Seguro ({days_left} dias)")
                    
    except Exception as e:
        resultado["status"] = f"Falha: {str(e)}"
        print(f"‚ö†Ô∏è {hostname}: Erro de conex√£o ou SSL.")
    
    return resultado

def salvar_auditoria(dados):
    historico = []
    if ARQUIVO_RELATORIO.exists():
        with open(ARQUIVO_RELATORIO, 'r') as f:
            try: historico = json.load(f)
            except: historico = []
    
    historico.append(dados)
    with open(ARQUIVO_RELATORIO, 'w') as f:
        json.dump(historico[-50:], f, indent=4) # Mant√©m as √∫ltimas 50 an√°lises

if __name__ == "__main__":
    relatorio_final = []
    for site in dominios:
        res = verificar_ssl(site)
        relatorio_final.append(res)
    
    salvar_auditoria(relatorio_final)
    print(f"üíæ Auditoria salva em: Data/{ARQUIVO_RELATORIO.name}")
[1;33m‚¨áÔ∏è  FIM DE ssl_hunter.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Monitor/system_expert.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3 
"""
N√çVEL 1: Agente de Diagn√≥stico de Infraestrutura
FUN√á√ÉO: Analisa comandos Linux e gera documenta√ß√£o formatada para comunidades.
CONCEITOS: Shell Integration, Log Parsing, Integra√ß√£o com API TLDR.
"""

import sys
import requests
import json
from pathlib import Path
from datetime import datetime

# --- BOOTSTRAP: CONEX√ÉO COM O SETTINGS ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    ARQUIVO_ENCICLOPEDIA = DIRS["DATA"] / "enciclopedia_linux.json"
except ImportError:
    ARQUIVO_ENCICLOPEDIA = BASE_DIR / "Data" / "enciclopedia_linux.json"
    ARQUIVO_ENCICLOPEDIA.parent.mkdir(parents=True, exist_ok=True)

def buscar_sabedoria(comando):
    # URLs de busca (Ordem: PT-BR Common -> Linux -> EN Common -> Linux)
    urls = [
        f"https://raw.githubusercontent.com/tldr-pages/tldr/main/pages.pt_BR/common/{comando}.md",
        f"https://raw.githubusercontent.com/tldr-pages/tldr/main/pages.pt_BR/linux/{comando}.md",
        f"https://raw.githubusercontent.com/tldr-pages/tldr/main/pages/common/{comando}.md",
        f"https://raw.githubusercontent.com/tldr-pages/tldr/main/pages/linux/{comando}.md"
    ]

    print(f"üîç Buscando conhecimento sobre: '{comando}'...")
    conteudo_raw = ""
    
    for url in urls:
        try:
            r = requests.get(url, timeout=5)
            if r.status_code == 200:
                conteudo_raw = r.text
                break
        except:
            continue

    if not conteudo_raw:
        print(f"‚ùå Comando '{comando}' n√£o encontrado na base TLDR.")
        return None

    return formatar_para_discord(comando, conteudo_raw)

def formatar_para_discord(comando, raw_text):
    linhas = raw_text.split('\n')
    saida_discord = f"**üí° Dica R√°pida: Dominando o `{comando}`**\n\n"
    
    for linha in linhas:
        if linha.startswith('>'): 
            saida_discord += f"_{linha.replace('>', '').strip()}_\n"
        elif linha.startswith('-'):
            saida_discord += f"\nüîπ **{linha.replace('-', '').strip()}**\n"
        elif linha.startswith('`'):
            codigo = linha.replace('`', '').strip()
            saida_discord += f"```bash\n{codigo}\n```"

    saida_discord += "\n_Fonte: tldr-pages | Curadoria: ToolBox_"
    return saida_discord

def arquivar_comando(comando, formatado):
    """Guarda a consulta na nossa base de dados local."""
    base = {}
    if ARQUIVO_ENCICLOPEDIA.exists():
        with open(ARQUIVO_ENCICLOPEDIA, 'r', encoding='utf-8') as f:
            base = json.load(f)
    
    base[comando] = {
        "data_consulta": datetime.now().strftime("%Y-%m-%d"),
        "conteudo": formatado
    }

    with open(ARQUIVO_ENCICLOPEDIA, 'w', encoding='utf-8') as f:
        json.dump(base, f, indent=4, ensure_ascii=False)
    print(f"üíæ Conhecimento arquivado em: {ARQUIVO_ENCICLOPEDIA.name}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        cmd_input = sys.argv[1]
    else:
        cmd_input = input("Qual comando Linux voc√™ quer explicar hoje? (ex: tar): ")

    resultado = buscar_sabedoria(cmd_input.lower())
    
    if resultado:
        print("\n" + "="*40)
        print(resultado)
        print("="*40 + "\n")
        arquivar_comando(cmd_input.lower(), resultado)
[1;33m‚¨áÔ∏è  FIM DE system_expert.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Monitor/watchdog_sentinela.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 2: Watchdog (Supervisor de Resili√™ncia)
FUN√á√ÉO: Valida o heartbeat do Sentinela e dispara alertas visuais no Fedora.
CONCEITOS: Auditoria de Heartbeat, Notifica√ß√£o de Sistema (GNOME), Resili√™ncia.
"""

import sys
import json
import subprocess
from pathlib import Path
from datetime import datetime

# --- BOOTSTRAP: CONEX√ÉO COM O SETTINGS ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    STATUS_SENTINELA = DIRS["JSON"] / "sentinela_status.json"
    LOG_SISTEMA = DIRS["LOGS"] / "system_toolbox.log"
except ImportError:
    STATUS_SENTINELA = Path("Data/json/sentinela_status.json")
    LOG_SISTEMA = Path("Logs/system_toolbox.log")

def enviar_notificacao_fedora(mensagem):
    """Sua ideia original: Alerta visual no GNOME/Fedora."""
    try:
        subprocess.run(['notify-send', '-u', 'critical', 'üö® ToolBox Watchdog', mensagem])
    except: pass

def auditar_sistema():
    print("üêï [Watchdog] Checando batimentos do Sentinela...")
    
    if not STATUS_SENTINELA.exists():
        msg = "Sentinela NUNCA foi iniciado!"
        registrar_e_notificar(msg)
        return

    try:
        with open(STATUS_SENTINELA, 'r', encoding='utf-8') as f:
            status = json.load(f)
        
        ultimo_check = datetime.strptime(status["ultimo_check"], "%Y-%m-%d %H:%M:%S")
        atraso = (datetime.now() - ultimo_check).total_seconds()

        # Se o Sentinela n√£o der sinal de vida por mais de 3 minutos
        if atraso > 180:
            msg = f"Sentinela travado! √öltimo sinal h√° {int(atraso)}s."
            registrar_e_notificar(msg)
        else:
            print(f"‚úÖ Sistema Saud√°vel. (Atraso: {int(atraso)}s)")

    except Exception as e:
        registrar_e_notificar(f"Erro na auditoria: {e}")

def registrar_e_notificar(msg):
    print(f"‚ö†Ô∏è {msg}")
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    # Escreve no Log Central
    with open(LOG_SISTEMA, 'a', encoding='utf-8') as f:
        f.write(f"{agora} - [WATCHDOG] - {msg}\n")
    # Envia o Popup no seu Fedora
    enviar_notificacao_fedora(msg)

if __name__ == "__main__":
    auditar_sistema()
[1;33m‚¨áÔ∏è  FIM DE watchdog_sentinela.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Monitor/web_monitor.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 2: Agente de Integridade de Redes
FUN√á√ÉO: Monitora disponibilidade e lat√™ncia de servi√ßos web cr√≠ticos.
CONCEITOS: Socket Programming, HTTP Status Monitoring, Tempo de Resposta.
"""

import sys
import requests
import json
import time
from pathlib import Path
from datetime import datetime

# --- BOOTSTRAP: CONEX√ÉO COM O SETTINGS ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS, LOGGING_CONF
    # Definimos onde salvar os resultados da inspe√ß√£o
    ARQUIVO_DATA = DIRS["DATA"] / "web_monitor_results.json"
    ARQUIVO_LOG = DIRS["LOGS"] / "web_monitor.log"
except ImportError:
    ARQUIVO_DATA = BASE_DIR / "Data" / "web_monitor_results.json"
    ARQUIVO_LOG = BASE_DIR / "Logs" / "web_monitor.log"
    ARQUIVO_DATA.parent.mkdir(parents=True, exist_ok=True)
    ARQUIVO_LOG.parent.mkdir(parents=True, exist_ok=True)

def explorar_site(url):
    # O Disfarce (User-Agent) atualizado
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
    }

    inicio = time.time()
    resultado = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "url": url,
        "status": None,
        "latencia_ms": 0,
        "bytes": 0,
        "sucesso": False
    }

    try:
        print(f"üõ∞Ô∏è  Tentando acessar: {url}")
        
        # Requisi√ß√£o com Timeout (Regra s√™nior para evitar scripts zumbis)
        response = requests.get(url, headers=headers, timeout=10)
        resultado["latencia_ms"] = round((time.time() - inicio) * 1000, 2)
        resultado["status"] = response.status_code
        resultado["bytes"] = len(response.text)

        if response.status_code == 200:
            print(f"‚úÖ Conex√£o estabelecida! ({resultado['latencia_ms']}ms)")
            resultado["sucesso"] = True
        else:
            print(f"‚ö†Ô∏è Servidor retornou c√≥digo: {response.status_code}")

    except Exception as e:
        erro_msg = f"‚ùå Erro na miss√£o: {e}"
        print(erro_msg)
        # Log de erro s√™nior
        with open(ARQUIVO_LOG, 'a', encoding='utf-8') as f:
            f.write(f"{resultado['timestamp']} - {url} - {erro_msg}\n")
    
    return resultado

def salvar_inspecao(dados):
    """Persist√™ncia de dados para an√°lise futura."""
    historico = []
    if ARQUIVO_DATA.exists():
        try:
            with open(ARQUIVO_DATA, 'r', encoding='utf-8') as f:
                historico = json.load(f)
        except:
            historico = []

    historico.append(dados)
    
    # Mant√©m apenas as √∫ltimas 100 inspe√ß√µes para n√£o inflar o JSON
    with open(ARQUIVO_DATA, 'w', encoding='utf-8') as f:
        json.dump(historico[-100:], f, indent=4, ensure_ascii=False)
    print(f"üíæ Resultado arquivado em: {ARQUIVO_DATA}")

if __name__ == "__main__":
    # Alvo vindo da sua vers√£o original
    alvo = "https://pt.wikipedia.org/wiki/Python"
    relatorio = explorar_site(alvo)
    salvar_inspecao(relatorio)
[1;33m‚¨áÔ∏è  FIM DE web_monitor.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Navegador/automatizar_formulario.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 2: Agente Navegador Aut√¥nomo
FUN√á√ÉO: Simula um usu√°rio acessando um site e preenchendo formul√°rios 
        Auxiliado por posicao_cursor_tela.py e Data/csv/produtos_automacao_formulario.csv  
CONCEITOS: Automa√ß√£o de Tarefas e Bots | Acesso a Informa√ß√µes de Arquivo CSV.
"""
import pyautogui
import time
import pandas as pd
from pathlib import Path
import webbrowser

# ---L√≥gica da Programa√ß√£o---
pyautogui.PAUSE = 0.5 

# Passo1: Entrar no sistema da empresa
site = "https://dlp.hashtagtreinamentos.com/python/intensivao/login"

# Tenta abrir o Firefox especificamente, se falhar, abre o padr√£o
try:
    print("Tentando abrir Firefox...")
    webbrowser.get('firefox').open(site)
except webbrowser.Error:
    print("Firefox n√£o encontrado, usando navegador padr√£o...")
    webbrowser.open(site)

# Passo2: Fazer Login
# Aumentamos para 6s para garantir que a INTERNET carregou o site
# Se sua internet oscilar, talvez precise de mais tempo.
time.sleep(6) 

# Clica no campo de e-mail
pyautogui.click(x=417, y=436)
pyautogui.write("hackeando_hashtag@gmail.com")
pyautogui.press("tab")
pyautogui.write("senha_hacker")
pyautogui.press("tab")
pyautogui.press("enter")

# Passo3: Abrir a base de dados
time.sleep(4) # Pausa para carregar a pr√≥xima p√°gina ap√≥s o login
CAMINHO_SCRIPT = Path(__file__).resolve().parent 
ARQUIVO_CSV = CAMINHO_SCRIPT.parent / "Data" / "csv" / "produtos_automacao_formulario.csv"
tabela = pd.read_csv(ARQUIVO_CSV) 

# Passo4: Cadastrar Produto
for linha in tabela.index:    
    # Clique inicial para garantir o foco
    pyautogui.click(x=439, y=320)
    
    # codigo   
    codigo = str(tabela.loc[linha, "codigo"])
    pyautogui.write(codigo)
    pyautogui.press("tab")
    
    # marca    
    marca = str(tabela.loc[linha, "marca"])
    pyautogui.write(marca)
    pyautogui.press("tab")
    
    # tipo    
    tipo = str(tabela.loc[linha, "tipo"])
    pyautogui.write(tipo)
    pyautogui.press("tab")
    
    # categoria    
    categoria = str(tabela.loc[linha, "categoria"])
    pyautogui.write(categoria)
    pyautogui.press("tab")
    
    # pre√ßo unit√°rio    
    preco = str(tabela.loc[linha, "preco_unitario"])
    pyautogui.write(preco)
    pyautogui.press("tab")
    
    # custo    
    custo = str(tabela.loc[linha, "custo"])
    pyautogui.write(custo)
    pyautogui.press("tab")
    
    # obs    
    obs = str(tabela.loc[linha, "obs"])
    if obs != "nan": 
       pyautogui.write(obs)
    pyautogui.press("tab")
    
    # Enviar
    pyautogui.press("enter") 
    
    # Rolar para cima para o pr√≥ximo loop
    pyautogui.press("pgup")
[1;33m‚¨áÔ∏è  FIM DE automatizar_formulario.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Navegador/automatizar_visual2.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 3: Agente Navegador Visual (Integrado ao ToolBox)
LOCAL: ~/Projetos/ToolBox/Agentes_Navegador/bot_formulario_visual.py
"""
import sys
import time
import pyautogui
import pandas as pd
import webbrowser
from pathlib import Path

# --- Configura√ß√£o de Caminhos (Din√¢mica e √† prova de falhas) ---
# O arquivo est√° em ToolBox/Agentes_Navegador
BASE_DIR = Path(__file__).resolve().parent.parent 
# Agora BASE_DIR = ~/Projetos/ToolBox

# Ajuste conforme o que tem dentro da sua pasta Data (csv ou inputs)
ARQUIVO_CSV = BASE_DIR / "Data" / "csv" / "produtos_automacao_formulario.csv"
PASTA_IMAGENS = BASE_DIR / "Data" / "ui_assets"

# Se a pasta Config for usada no futuro, ela j√° est√° mapeada
sys.path.append(str(BASE_DIR))

# --- Configura√ß√µes Visuais ---
CONFIDENCE_LEVEL = 0.7 
pyautogui.PAUSE = 0.5

def esperar_e_clicar(nome_imagem, tempo_limite=20, offset_x=0, offset_y=0):
    """Busca visual com timeout e offset."""
    caminho_img = str(PASTA_IMAGENS / nome_imagem)
    inicio = time.time()
    
    while True:
        try:
            localizacao = pyautogui.locateCenterOnScreen(caminho_img, confidence=CONFIDENCE_LEVEL, grayscale=True)
            if localizacao:
                x, y = localizacao
                pyautogui.click(x + offset_x, y + offset_y)
                return True
        except pyautogui.ImageNotFoundException:
            pass 
        except Exception:
            pass # Ignora erros pontuais de leitura

        if time.time() - inicio > tempo_limite:
            return False
        time.sleep(0.5)

# --- EXECU√á√ÉO ---
print(f"üîß [KERNEL] Iniciando processo em: {BASE_DIR}")

# 1. Carregamento e Higieniza√ß√£o Inteligente (A Maestria com Pandas)
try:
    print("   üìÇ Lendo e tratando dados...", end=" ")
    tabela = pd.read_csv(ARQUIVO_CSV)
    
    # Tratamento em lote (muito mais r√°pido que fazer no loop)
    tabela["obs"] = tabela["obs"].fillna("") 
    tabela["custo"] = tabela["custo"].fillna(0)
    
    # Converte colunas num√©ricas para string e ajusta v√≠rgula de uma vez
    cols_numericas = ["preco_unitario", "custo"]
    for col in cols_numericas:
        tabela[col] = tabela[col].astype(str).str.replace(".", ",", regex=False)
        
    print("Feito!")
except FileNotFoundError:
    print(f"\n‚ùå Erro Cr√≠tico: N√£o achei o CSV em: {ARQUIVO_CSV}")
    print("   Verifique se a pasta 'csv' existe dentro de 'Data'.")
    exit()

# 2. Navegador
site = "https://dlp.hashtagtreinamentos.com/python/intensivao/login"
try:
    webbrowser.get('firefox').open(site)
except:
    webbrowser.open(site)

# 3. Login
if esperar_e_clicar("campo_email_automatizar_visual.png", offset_y=35):
    pyautogui.write("hackeando_hashtag@gmail.com")    
    pyautogui.press("tab")
    pyautogui.write("senha_hacker")
    pyautogui.press("tab")
    pyautogui.press("enter")
else:
    print("‚ùå Falha no Login: Campo n√£o encontrado.")
    exit()

# 4. Loop de Preenchimento (Agora limpo e r√°pido)
for i, linha in enumerate(tabela.index):
    print(f"   üìù Processando item {i+1}/{len(tabela)}", end="\r")
    
    # Sincronia Visual (Ancoragem)
    if not esperar_e_clicar("campo_codigo_automatizar_visual.png", tempo_limite=3, offset_y=35):
        pyautogui.press("tab") # Fallback se a vis√£o falhar
    
    # Preenchimento (Dados j√° est√£o limpos)
    pyautogui.write(str(tabela.loc[linha, "codigo"]))
    pyautogui.press("tab")
    
    pyautogui.write(str(tabela.loc[linha, "marca"]))
    pyautogui.press("tab")
    
    pyautogui.write(str(tabela.loc[linha, "tipo"]))
    pyautogui.press("tab")
    
    pyautogui.write(str(tabela.loc[linha, "categoria"]))
    pyautogui.press("tab")
    
    pyautogui.write(tabela.loc[linha, "preco_unitario"]) # J√° formatado
    pyautogui.press("tab")
    
    pyautogui.write(tabela.loc[linha, "custo"]) # J√° formatado
    pyautogui.press("tab")
    
    obs = tabela.loc[linha, "obs"]
    if obs:
       pyautogui.write(str(obs))
    pyautogui.press("tab")
    
    pyautogui.press("enter")
    pyautogui.press("pgup")
    time.sleep(0.5)

print("\n‚úÖ Automa√ß√£o Finalizada com Sucesso.")
[1;33m‚¨áÔ∏è  FIM DE automatizar_visual2.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Navegador/automatizar_visual.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 3: Agente Navegador com Vis√£o Computacional
FUN√á√ÉO: Localiza elementos na tela por imagem.
        Sincroniza visualmente a cada produto para n√£o perder o passo.
DEPEND√äNCIAS: pip install opencv-python pyautogui pandas
"""
import pyautogui
import time
import pandas as pd
from pathlib import Path
import webbrowser

# --- Configura√ß√µes ---
CONFIDENCE_LEVEL = 0.7 
pyautogui.PAUSE = 0.5

# Caminhos
CAMINHO_SCRIPT = Path(__file__).resolve().parent
ARQUIVO_CSV = CAMINHO_SCRIPT.parent / "Data" / "csv" / "produtos_automacao_formulario.csv"
PASTA_IMAGENS = CAMINHO_SCRIPT.parent / "Data" / "ui_assets"

# --- Fun√ß√£o Visual ---
def esperar_e_clicar(nome_imagem, tempo_limite=20, offset_x=0, offset_y=0):
    caminho_img = str(PASTA_IMAGENS / nome_imagem)
    inicio = time.time()
    # print(f"Procurando: {nome_imagem}...") # Comentei para limpar o terminal
    
    while True:
        try:
            localizacao = pyautogui.locateCenterOnScreen(caminho_img, confidence=CONFIDENCE_LEVEL, grayscale=True)
            if localizacao:
                x, y = localizacao
                pyautogui.click(x + offset_x, y + offset_y)
                return True
        except pyautogui.ImageNotFoundException:
            pass 
        except Exception:
            pass

        if time.time() - inicio > tempo_limite:
            return False
        time.sleep(0.5)

# --- In√≠cio ---
print("Iniciando Agente Visual...")
site = "https://dlp.hashtagtreinamentos.com/python/intensivao/login"

try:
    webbrowser.get('firefox').open(site)
except:
    webbrowser.open(site)

# Login
if esperar_e_clicar("campo_email_automatizar_visual.png", offset_y=35):
    pyautogui.write("hackeando_hashtag@gmail.com")    
    pyautogui.press("tab")
    pyautogui.write("senha_hacker")
    pyautogui.press("tab")
    pyautogui.press("enter")
else:
    print("‚ùå Erro: Login falhou (Imagem n√£o encontrada)")
    exit()

# Dados
tabela = pd.read_csv(ARQUIVO_CSV)

# Cadastro (Loop Sincronizado)
for linha in tabela.index:
    
    # 1. SINCRONIZA√á√ÉO VISUAL
    # Tenta clicar no campo c√≥digo. Se falhar visualmente, usa o TAB como emerg√™ncia.
    if not esperar_e_clicar("campo_codigo_automatizar_visual.png", tempo_limite=3, offset_y=35):
        print(f"‚ö†Ô∏è Aviso: Sincronia visual perdida na linha {linha}. Tentando TAB.")
        pyautogui.press("tab")
    
    # Se o clique funcionou, o cursor J√Å est√° no lugar certo. E o TAB de emerg√™ncia n√£o ocorrer√°.
    
    # 1. C√≥digo
    codigo = str(tabela.loc[linha, "codigo"])
    pyautogui.write(codigo)
    pyautogui.press("tab")
    
    # 2. Marca
    marca = str(tabela.loc[linha, "marca"])
    pyautogui.write(marca)
    pyautogui.press("tab")
    
    # 3. Tipo
    tipo = str(tabela.loc[linha, "tipo"])
    pyautogui.write(tipo)
    pyautogui.press("tab")
    
    # 4. Categoria
    categoria = str(tabela.loc[linha, "categoria"])
    pyautogui.write(categoria)
    pyautogui.press("tab")
    
    # 5. Pre√ßo (Com tratamento de V√≠rgula)
    preco = str(tabela.loc[linha, "preco_unitario"])
    preco = preco.replace(".", ",") 
    pyautogui.write(preco)
    pyautogui.press("tab")
    
    # 6. Custo (Com tratamento de V√≠rgula e Vazio)
    custo = str(tabela.loc[linha, "custo"])
    if custo == "nan": custo = "0"
    custo = custo.replace(".", ",")
    pyautogui.write(custo)
    pyautogui.press("tab")
    
    # 7. Obs
    obs = str(tabela.loc[linha, "obs"])
    if obs != "nan":
       pyautogui.write(obs)
    pyautogui.press("tab")
    
    # Enviar e Reiniciar
    pyautogui.press("enter")
    pyautogui.press("pgup")
    # Pequena pausa para a tela rolar antes de procurar a imagem de novo
    time.sleep(0.5)
[1;33m‚¨áÔ∏è  FIM DE automatizar_visual.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Navegador/posicao_cursor_tela.py[0m
[0;36m==================================================[0m
import time
import pyautogui

time.sleep(5)
print(pyautogui.position())

pyautogui.scroll(200)
[1;33m‚¨áÔ∏è  FIM DE posicao_cursor_tela.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Visao/vision_processor.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 3: Processador de Vis√£o Computacional (Vision Processor)
FUN√á√ÉO: Higieniza√ß√£o e formata√ß√£o de fotos de perfil (LinkedIn Style) em lote.
CONCEITOS: Pillow, Pipeline de I/O, Processamento em Batch.
"""

import sys
from pathlib import Path
from PIL import Image, ImageOps, ImageDraw

# --- BOOTSTRAP: CONEX√ÉO COM O SETTINGS ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    # MUDAN√áA ESTRUTURAL:
    # input_images -> Onde voc√™ joga as fotos
    # output_images -> Onde o rob√¥ entrega o resultado
    DIR_ENTRADA = DIRS["IN_IMAGES"]
    DIR_SAIDA = DIRS["OUT_IMAGES"]
except ImportError:
    # Fallback seguro
    DIR_ENTRADA = BASE_DIR / "Data" / "input_images"
    DIR_SAIDA = BASE_DIR / "Data" / "output_images"

# Garante a infraestrutura f√≠sica
DIR_ENTRADA.mkdir(parents=True, exist_ok=True)
DIR_SAIDA.mkdir(parents=True, exist_ok=True)

def processar_foto(caminho_arquivo):
    """Aplica a l√≥gica de design (Corte Circular + Zoom)"""
    try:
        nome_arquivo = Path(caminho_arquivo).name
        print(f"   üñºÔ∏è  Processando: {nome_arquivo}...", end=" ")
        
        img = Image.open(caminho_arquivo)
        img = ImageOps.exif_transpose(img) # Corrige rota√ß√£o de celular
        img = img.convert("RGBA")
        
        # 1. L√≥gica de Zoom (Foco no rosto)
        fator_zoom = 0.20 
        borda = int(min(img.size) * fator_zoom)
        img_com_borda = ImageOps.expand(img, border=borda, fill='white')

        # 2. Corte Quadrado Centralizado (Foco 35% do topo)
        min_lado = min(img_com_borda.size)
        tamanho_quadrado = (min_lado, min_lado)
        img_quadrada = ImageOps.fit(img_com_borda, tamanho_quadrado, centering=(0.5, 0.35))
        
        # 3. M√°scara Circular (Alpha Channel)
        mascara = Image.new('L', tamanho_quadrado, 0)
        draw = ImageDraw.Draw(mascara)
        draw.ellipse((0, 0) + tamanho_quadrado, fill=255)
        img_quadrada.putalpha(mascara)

        # 4. Resize final e Salvamento
        img_final = img_quadrada.resize((500, 500), Image.Resampling.LANCZOS)
        
        nome_saida = f"perfil_{Path(nome_arquivo).stem}.png"
        caminho_final = DIR_SAIDA / nome_saida
        
        img_final.save(caminho_final, "PNG", optimize=True)
        print(f"‚úÖ Feito!")
        return True

    except Exception as e:
        print(f"‚ùå Falha: {e}")
        return False

def executar_pipeline():
    print(f"üëÅÔ∏è  [Vision Processor] Monitorando esteira: {DIR_ENTRADA}")
    
    # Extens√µes suportadas
    extensoes = ['*.jpg', '*.jpeg', '*.png', '*.webp']
    arquivos = []
    for ext in extensoes:
        arquivos.extend(DIR_ENTRADA.glob(ext))
    
    if not arquivos:
        print(f"üí§ A pasta de entrada est√° vazia.")
        print(f"   üëâ Dica: Coloque fotos em: {DIR_ENTRADA}")
        return

    print(f"üîé Encontradas {len(arquivos)} imagens para processar.\n")
    
    sucessos = 0
    for arquivo in arquivos:
        if processar_foto(arquivo):
            sucessos += 1
            
    print(f"\nüöÄ Processamento conclu√≠do. {sucessos}/{len(arquivos)} imagens geradas.")
    print(f"üìÇ Resultados dispon√≠veis em: {DIR_SAIDA}")

if __name__ == "__main__":
    # Se passar argumento, processa s√≥ um. Se n√£o, varre a pasta.
    if len(sys.argv) > 1:
        arquivo_alvo = Path(sys.argv[1])
        # Se o usu√°rio passou s√≥ o nome, assumimos que est√° na pasta de input
        if not arquivo_alvo.exists():
            arquivo_alvo = DIR_ENTRADA / sys.argv[1]
        
        if arquivo_alvo.exists():
            print("üëÅÔ∏è  Modo Manual Ativado")
            processar_foto(arquivo_alvo)
            print(f"üìÇ Sa√≠da: {DIR_SAIDA}")
        else:
            print(f"‚ùå Arquivo n√£o encontrado: {arquivo_alvo}")
    else:
        executar_pipeline()
[1;33m‚¨áÔ∏è  FIM DE vision_processor.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Agentes_Voz/voice_synthesizer.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3
"""
N√çVEL 4: Sintetizador de Intelig√™ncia Auditiva (Voice Cloner)
FUN√á√ÉO: Processamento de √°udio e s√≠ntese vocal (TTS) com auto-convers√£o de formatos.
CONCEITOS: DSP, Wrappers de FFmpeg, Pipeline de √Åudio Automatizado.
"""

import sys
import os
import subprocess
import shutil
from pathlib import Path
# [NOVO] Aceite autom√°tico da licen√ßa para n√£o travar o rob√¥
os.environ["COQUI_TOS_AGREED"] = "1"
import torch
from TTS.api import TTS

# --- BOOTSTRAP: CONEX√ÉO COM O SETTINGS ---
BASE_DIR = Path(__file__).resolve().parent.parent
if str(BASE_DIR) not in sys.path:
    sys.path.append(str(BASE_DIR))

try:
    from Config.settings import DIRS
    DIR_ENTRADA = DIRS["IN_VOICE"]   # Data/input_audio
    DIR_SAIDA = DIRS["OUT_VOICE"]    # Data/output_audio
except ImportError:
    # Fallback
    DIR_ENTRADA = BASE_DIR / "Data" / "input_audio"
    DIR_SAIDA = BASE_DIR / "Data" / "output_audio"

# Garante infraestrutura
DIR_ENTRADA.mkdir(parents=True, exist_ok=True)
DIR_SAIDA.mkdir(parents=True, exist_ok=True)

# --- CONFIGURA√á√ÉO DE ARQUIVOS ---
NOME_ROTEIRO = "roteiro.txt"
NOME_REF_M4A = "referencia.m4a"
NOME_REF_WAV = "referencia.wav"
NOME_FINAL = "audio_clonado_final.wav"

def preparar_audio_referencia():
    """Converte M4A para WAV automaticamente se necess√°rio."""
    caminho_m4a = DIR_ENTRADA / NOME_REF_M4A
    caminho_wav = DIR_ENTRADA / NOME_REF_WAV

    # Se j√° tem o WAV, beleza.
    if caminho_wav.exists():
        print(f"‚úÖ √Åudio de refer√™ncia (WAV) encontrado: {caminho_wav.name}")
        return caminho_wav

    # Se n√£o tem WAV, mas tem M4A, converte.
    if caminho_m4a.exists():
        print(f"üîÑ Convertendo {caminho_m4a.name} para WAV...")
        try:
            comando = [
                'ffmpeg', '-i', str(caminho_m4a), 
                str(caminho_wav), '-y', '-loglevel', 'error'
            ]
            subprocess.run(comando, check=True)
            print("‚úÖ Convers√£o conclu√≠da com sucesso.")
            return caminho_wav
        except Exception as e:
            print(f"‚ùå Erro ao converter √°udio (Voc√™ tem ffmpeg instalado?): {e}")
            return None
            
    print(f"‚ùå ERRO: Nenhum arquivo de voz encontrado em {DIR_ENTRADA}")
    print(f"   üëâ Coloque '{NOME_REF_M4A}' ou '{NOME_REF_WAV}' l√°.")
    return None

def ler_roteiro():
    caminho_roteiro = DIR_ENTRADA / NOME_ROTEIRO
    if not caminho_roteiro.exists():
        print(f"‚ùå Roteiro n√£o encontrado: {caminho_roteiro}")
        print(f"   üëâ Crie um arquivo '{NOME_ROTEIRO}' em {DIR_ENTRADA}")
        return None
    
    with open(caminho_roteiro, "r", encoding="utf-8") as f:
        return f.read()

def processar_sintese():
    print("üé¨ Iniciando Est√∫dio de Voz (V4 - Auto)...")
    
    # 1. Prepara√ß√£o de Arquivos
    arquivo_ref = preparar_audio_referencia()
    if not arquivo_ref: return

    texto_bruto = ler_roteiro()
    if not texto_bruto: return

    # 2. Processamento de Texto
    texto_limpo = texto_bruto.replace("\n", " ")
    frases = [f.strip() for f in texto_limpo.replace("!", ".").replace("?", ".").split(".") if len(f.strip()) > 2]
    
    print(f"‚úÇÔ∏è  Roteiro dividido em {len(frases)} blocos.")

    # 3. Carregar IA
    device = "cuda" if torch.cuda.is_available() else "cpu"
    print(f"‚è≥ Carregando modelo XTTS (Dispositivo: {device})...")
    try:
        tts = TTS("tts_models/multilingual/multi-dataset/xtts_v2").to(device)
    except Exception as e:
        print(f"‚ùå Erro ao carregar modelo TTS: {e}")
        return

    # 4. Gera√ß√£o em Loop
    pasta_temp = DIR_SAIDA / "temp_parts"
    pasta_temp.mkdir(exist_ok=True)
    
    arquivos_gerados = []
    print("üéôÔ∏è  Gravando...")

    for i, frase in enumerate(frases):
        caminho_temp = pasta_temp / f"parte_{i:03d}.wav"
        print(f"   [{i+1}/{len(frases)}] Sintetizando: \"{frase[:30]}...\"")
        
        try:
            tts.tts_to_file(
                text=frase,
                speaker_wav=str(arquivo_ref),
                language="pt",
                file_path=str(caminho_temp)
            )
            arquivos_gerados.append(caminho_temp)
        except Exception as e:
            print(f"   ‚ö†Ô∏è Falha no bloco {i}: {e}")

    # 5. Unifica√ß√£o (Merge)
    if arquivos_gerados:
        print("üîó Unificando √°udios...")
        caminho_lista = pasta_temp / "lista_files.txt"
        caminho_final = DIR_SAIDA / NOME_FINAL
        
        with open(caminho_lista, "w") as f:
            for arq in arquivos_gerados:
                f.write(f"file '{arq.name}'\n")
        
        # Comando FFmpeg para concatenar
        cmd = f"ffmpeg -f concat -safe 0 -i {caminho_lista} -c copy {caminho_final} -y -loglevel error"
        
        # Executa comando no diret√≥rio da pasta tempor√°ria para evitar problemas de path
        subprocess.run(cmd, shell=True, cwd=pasta_temp)
        
        # Limpeza
        shutil.rmtree(pasta_temp)
        print(f"\n‚úÖ SUCESSO ABSOLUTO!\n   üéß Ou√ßa agora: {caminho_final}")
    else:
        print("‚ùå Nenhum √°udio foi gerado.")

if __name__ == "__main__":
    processar_sintese()
[1;33m‚¨áÔ∏è  FIM DE voice_synthesizer.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./Config/settings.py[0m
[0;36m==================================================[0m
"""
N√çVEL 1: Gestor de Ambiente e Caminhos (Vers√£o Agentes V2)
FUN√á√ÉO: Centraliza a intelig√™ncia de diret√≥rios e separa√ß√£o por tipo de dado.
CONCEITOS: Abstra√ß√£o de Caminhos, Configura√ß√£o Centralizada, Higiene de Dados.
"""

import os
from pathlib import Path

# Caminho Base do Projeto (Raiz da ToolBox)
BASE_DIR = Path(__file__).resolve().parent.parent

# 1. Defini√ß√£o dos Novos Dom√≠nios de Agentes e Infraestrutura
DIRS = {
    # Dom√≠nios de Agentes (L√≥gica/Scripts)
    "AGENTES_DADOS": BASE_DIR / "Agentes_Dados",
    "AGENTES_MONITOR": BASE_DIR / "Agentes_Monitor",
    "AGENTES_VISAO": BASE_DIR / "Agentes_Visao",
    "AGENTES_VOZ": BASE_DIR / "Agentes_Voz",
    
    # Infraestrutura
    "CONFIG": BASE_DIR / "Config",
    "SCRIPTS": BASE_DIR / "Scripts",
    "LOGS": BASE_DIR / "Logs",
    "ASSETS": BASE_DIR / "Assets",
    
    # Reposit√≥rio Central de Dados (Persist√™ncia Estruturada)
    "DATA": BASE_DIR / "Data",
    "JSON": BASE_DIR / "Data" / "json",
    "CSV": BASE_DIR / "Data" / "csv",
    
    # Pipelines de I/O de M√≠dia (Bin√°rios)
    "IN_IMAGES": BASE_DIR / "Data" / "input_images",
    "OUT_IMAGES": BASE_DIR / "Data" / "output_images",
    "IN_VOICE": BASE_DIR / "Data" / "input_audio",
    "OUT_VOICE": BASE_DIR / "Data" / "output_audio"
}

# 2. Automa√ß√£o de Infraestrutura: Garante que TODAS as pastas existam
for folder_path in DIRS.values():
    folder_path.mkdir(parents=True, exist_ok=True)

# 3. Configura√ß√µes de Logs Globais
LOGGING_CONF = {
    "format": '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    "datefmt": '%Y-%m-%d %H:%M:%S',
    "arquivo_log": DIRS["LOGS"] / "system_toolbox.log"
}

# 4. Configura√ß√µes de C√¢mbio (Agora apontando para a subpasta CSV)
CAMBIO_CONFIG = {
    "url_api": "https://economia.awesomeapi.com.br/last/USD-BRL",
    "arquivo_saida": DIRS["CSV"] / "cotacao_dolar.csv"
}
[1;33m‚¨áÔ∏è  FIM DE settings.py[0m

[0;36m==================================================[0m
[0;36müìÅ ARQUIVO: ./main.py[0m
[0;36m==================================================[0m
#!/usr/bin/env python3 
"""
ORQUESTRADOR: main.py
FUN√á√ÉO: Gerador de Documenta√ß√£o Viva (Living Documentation).
DESCRI√á√ÉO: Varre a estrutura do projeto e atualiza todos os README.md automaticamente.
STATUS: Operacional - Modo Bibliotec√°rio S√™nior 
"""

import os
import re
import subprocess
from pathlib import Path

# --- CONFIGURA√á√ïES DE IGNORAR ---
# Apenas lixo de sistema e controle de vers√£o. Pastas de output S√ÉO PERMITIDAS.
DIRS_IGNORADOS = {'.venv', '__pycache__', '.git', '.idea', '.vscode'}

# --- 1. MANIFESTO DO PROJETO ---
MANIFESTO = """# üõ†Ô∏è ToolBox - Ecossistema de Agentes Aut√¥nomos

### üìÇ Vis√£o Geral e Arquitetura
Este reposit√≥rio opera atrav√©s de **Agentes Especializados** e uma infraestrutura de dados organizada por tipos e dom√≠nios.

* **Agentes de Dados:** Intelig√™ncia de busca, scraping e coleta de dados.
* **Agentes de Visao:** Processamento de imagem, higieniza√ß√£o e privacidade.
* **Agentes de Voz:** S√≠ntese vocal (TTS/XTTS) e intelig√™ncia auditiva.
* **Infraestrutura:** Gest√£o de logs, configura√ß√µes e persist√™ncia de dados.

---
"""

# --- 2. STACK TECNOL√ìGICO DETALHADO (RESTAURADO) ---
STACK_TECNOLOGICO = """
---
### üõ†Ô∏è Stack Tecnol√≥gico e Engenharia
- **Core Executivo:** Python 3.10+ & Bash Scripting (Automa√ß√£o de Infraestrutura).
- **Dom√≠nios de Intelig√™ncia:**
    - `Coqui TTS (XTTS v2)`: Clonagem de voz Neural e S√≠ntese de Fala de alta fidelidade.
    - `Pillow (PIL)`: Pipeline de processamento de imagem e manipula√ß√£o de metadados.
    - `Requests` & `BeautifulSoup4`: Engenharia de extra√ß√£o e consumo de dados.
- **Resili√™ncia e Monitoramento:**
    - `Logging (RotatingFileHandler)`: Gest√£o de logs c√≠clicos com controle de volumetria.
    - `Subprocess`: Orquestra√ß√£o de comandos do sistema operacional (Fedora/Linux).
- **Arquitetura de Dados:**
    - **Persist√™ncia Estruturada:** Armazenamento em CSV (S√©ries) e JSON (Metadados).
    - **Estrat√©gia de I/O:** Separa√ß√£o rigorosa entre `input_` (Mat√©ria-prima) e `output_` (Processados).
    - **Living Documentation:** Mapeamento din√¢mico via `main.py` (incluindo estruturas vazias via `.gitkeep`).
"""

# --- 3. DEFINI√á√ïES POR DOM√çNIO ---
DEFINICOES = {
    "Agentes_Dados": "Coleta e processamento de not√≠cias e oportunidades (Scraping/RSS).",
    "Agentes_Visao": "Processamento de imagens, filtros e remo√ß√£o de metadados.",
    "Agentes_Voz": "Convers√£o de texto em fala (TTS/XTTS) e intelig√™ncia auditiva.",
    "Agentes_Monitor": "Monitoramento de integridade web e diagn√≥stico de hardware/OS.",
    "Scripts": "Utilit√°rios de manuten√ß√£o, backup e automa√ß√£o de infraestrutura.",
    "Config": "C√©rebro do projeto (Settings, caminhos absolutos e vari√°veis).",
    "Data": "Reposit√≥rio central organizado por subpastas (csv, json, images, audio).",
    "Logs": "Registro de atividades, hist√≥rico de erros e auditoria."
}

MAPA_MODULOS = {
    "Agentes_Dados": "### üõ∞Ô∏è /Agentes_Dados",
    "Agentes_Visao": "### üëÅÔ∏è /Agentes_Visao",
    "Agentes_Voz": "### üéôÔ∏è /Agentes_Voz",
    "Agentes_Monitor": "### üñ•Ô∏è /Agentes_Monitor",
    "Scripts": "### üìú /Scripts",
    "Data": "### üìä /Data",
    "Logs": "### üìù /Logs"
}

# --- 4. L√ìGICA DE EXTRA√á√ÉO E AUDITORIA ---

def extrair_docstring(filepath):
    """L√™ o cabe√ßalho do arquivo para explicar o que ele faz."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            conteudo = f.read()
            if filepath.endswith('.py'):
                match = re.search(r'"""(.*?)"""', conteudo, re.DOTALL)
                if match: return f" | *{match.group(1).strip().replace(chr(10), ' ')}*"
            elif filepath.endswith('.sh'):
                comentarios = []
                for l in conteudo.split('\n'):
                    if l.startswith('#') and '!' not in l:
                        comentarios.append(l.replace('#', '').strip())
                if comentarios: return f" | *{' '.join(comentarios[:1])}*"
    except: pass
    return ""

def get_git_info(filepath):
    """Pega a data da √∫ltima modifica√ß√£o real no Git."""
    try:
        cmd = ['git', 'log', '-1', '--format=%cd', '--date=short', filepath]
        result = subprocess.run(cmd, capture_output=True, text=True)
        return f"({result.stdout.strip()})" if result.stdout.strip() else "(Novo/Local)"
    except: return "(Local)"

def gerar_lista_arquivos(pasta_raiz, link_relativo=True):
    linhas = []
    
    # Varredura
    for root, dirs, files in os.walk(pasta_raiz):
        # Filtra pastas ignoradas
        dirs[:] = [d for d in dirs if d not in DIRS_IGNORADOS]
        
        for f in files:
            # Regra de Ouro: Ignora ocultos, EXCETO .gitkeep
            if f.startswith('.') and f != '.gitkeep': continue 
            if f == 'README.md': continue
            
            caminho_completo = os.path.join(root, f)
            nome_exibicao = os.path.relpath(caminho_completo, pasta_raiz)
            
            # Defini√ß√£o de √çcones e Descri√ß√µes
            icone = "üìÑ"
            info_git = get_git_info(caminho_completo)
            desc = extrair_docstring(caminho_completo)
            
            if f == '.gitkeep':
                icone = "üìÇ"
                # Remove o nome .gitkeep da exibi√ß√£o para ficar mais limpo
                pasta_pai = os.path.dirname(nome_exibicao)
                nome_exibicao = f"{pasta_pai}/ (Estrutura)"
                desc = " | *Diret√≥rio de Output (Mantido via .gitkeep)*"
            elif f.endswith('.py'): icone = "üêç"
            elif f.endswith('.sh'): icone = "üêö"
            elif f.endswith(('.wav', '.mp3')): icone = "üîä"
            elif f.endswith(('.jpg', '.png')): icone = "üñºÔ∏è"
            elif f.endswith('.json'): icone = "‚öôÔ∏è"
            
            # Cria o link Markdown
            prefixo = f"./{pasta_raiz}/" if not link_relativo else "./"
            # Se for gitkeep, o link aponta para a pasta
            link = f"{prefixo}{os.path.dirname(os.path.relpath(caminho_completo, pasta_raiz))}" if f == '.gitkeep' else f"{prefixo}{nome_exibicao}"
            
            if f == '.gitkeep':
                 linhas.append(f"- {icone} **[{nome_exibicao}]({link})** {desc}")
            else:
                 linhas.append(f"- {icone} **[{nome_exibicao}]({link})** {info_git}{desc}")

    return sorted(linhas) if linhas else ["- *Pasta vazia.*"]

# --- 5. EXECU√á√ÉO ---

def main():
    print(f"üìö Iniciando Bibliotec√°rio ToolBox em: {os.getcwd()}")
    
    # 1. Gera o README.md Principal (Raiz)
    conteudo_raiz = MANIFESTO
    
    for pasta, header in MAPA_MODULOS.items():
        if os.path.exists(pasta):
            print(f"   - Indexando: {pasta}...")
            conteudo_raiz += f"\n{header}\n> {DEFINICOES.get(pasta, '')}\n\n"
            conteudo_raiz += "\n".join(gerar_lista_arquivos(pasta, link_relativo=False)) + "\n"
            
    conteudo_raiz += STACK_TECNOLOGICO
    
    with open('README.md', 'w', encoding='utf-8') as f:
        f.write(conteudo_raiz)
    
    # 2. Gera os READMEs Internos (Dentro de cada pasta)
    for pasta in DEFINICOES.keys():
        if os.path.exists(pasta):
            with open(os.path.join(pasta, "README.md"), 'w', encoding='utf-8') as f:
                f.write(f"# üìÅ M√≥dulo: {pasta}\n\n> {DEFINICOES[pasta]}\n\n## üß∞ Estrutura e Ferramentas\n")
                f.write("\n".join(gerar_lista_arquivos(pasta, link_relativo=True)))

    print("‚úÖ Documenta√ß√£o Viva atualizada (Stack S√™nior + Outputs)!")

if __name__ == "__main__":
    main()
[1;33m‚¨áÔ∏è  FIM DE main.py[0m

[0;32m‚úÖ Auditoria Finalizada.[0m
